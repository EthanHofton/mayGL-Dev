#version 400

out vec4 fragColor;

uniform vec2 zoom;
uniform vec2 trans;
uniform int numIter;
uniform int cutoff;
uniform vec3 color;

in VSOUT {
    vec2 i_texCoords;
} vsin;

vec3 hsv2rgb(vec3 c)
{
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

float map(float value, float min1, float max1, float min2, float max2) {
  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

// return real part
float fr(float za, float zb, float ca) {
    return za*za - zb*zb + ca;
}

// return imaginary part
float fi(float za, float zb, float cb) {
    return 2 * za * zb + cb;
}

void main() 
{
    float min = zoom.x;
    float max = zoom.y;
    float pixelPosA = trans.x + map(vsin.i_texCoords.x, 0, 1, min, max);
    float pixelPosB = trans.y + map(vsin.i_texCoords.y, 0, 1, min, max);

    int n = 0;

    float a = fr(0, 0, pixelPosA);
    float b = fi(0, 0, pixelPosB);

    for (; n < numIter; n++) {
        float aCopy = a;
        float bCopy = b;
        a = fr(aCopy, bCopy, pixelPosA);
        b = fi(aCopy, bCopy, pixelPosB);

        if (abs(a + b) > cutoff) {
            break;
        }
    }

    float hue = map(n, 0, numIter, 0, 1);
    float v = hue;
    if (n == numIter)
    {
        v = 0;
    }

    fragColor = vec4(color, 1) * vec4(hsv2rgb(vec3(hue ,255, v)), 1);
}